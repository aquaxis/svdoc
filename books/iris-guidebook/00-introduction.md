---
title: "序章 IRISへようこそ"
---

# 序章 IRISへようこそ

## 本章のゴール

- IRIS言語の概要を理解する
- SystemVerilogとの違いを把握する
- 本書の学習フローを理解する

---

## 0.1 IRISとは

**IRIS**（アイリス: Immutable RTL Implementation Standard）は、SystemVerilogの複雑さを解消し、Rustの設計思想を取り入れたハードウェア記述言語です。

### 設計思想

IRISは以下の原則に基づいて設計されています：

| 原則 | 説明 |
|------|------|
| **Safety First** | 暗黙の型変換を廃止、ビット幅不一致はコンパイルエラー |
| **明示性 > 暗黙性** | 意図を明確にコードで表現 |
| **簡潔性** | `{}`記法、統一されたデータ型、統一された代入演算子 |
| **構成可能性** | モジュール間の疎結合設計 |
| **合成と検証の分離** | 合成可能/検証専用コードの明確な区別 |

> **なぜ「Immutable」なのか**: IRISの名称には「Immutable」が含まれますが、ハードウェア記述には状態変化が不可欠です。この名称は、**組み合わせ論理における単一代入の強制**や**Multi Driveの禁止**など、「予期せぬ副作用を排除する」設計思想を表しています。

### 主要な特徴

1. **代入演算子の統一**: ブロッキング代入（`=`）とノンブロッキング代入（`<=`）の概念を廃止し、代入演算子を `=` に統一
2. **型安全性**: 暗黙の型変換を禁止し、すべての型変換は明示的に行う
3. **Multi Drive禁止**: 同一信号への複数複数箇所からの駆動をコンパイル時にエラーとして検出
4. **簡潔な構文**: 予約語数は約54語（SystemVerilogは約220語）

---

## 0.2 なぜIRISを学ぶのか

### SystemVerilogの問題点

SystemVerilogは強力なハードウェア記述言語ですが、以下の問題を抱えています：

- **複雑な構文**: 歴史的経緯により約220の予約語を持つ
- **暗黙の型変換**: バグの温床となる
- **冗長な記法**: `begin...end` など
- **型の混乱**: `reg`, `wire`, `logic` の使い分けが不明確
- **意図しないラッチ生成**: リスクが高い
- **代入演算子の混乱**: ブロッキング代入とノンブロッキング代入の使い分け

### IRISによる解決

| SystemVerilogの問題 | IRISの解決策 |
|---------------------|--------------|
| 同じ機能に複数構文 | 一機能一構文 |
| 暗黙の型変換 | 明示的型付け + 型推論 |
| 歴史的経緯による複雑さ | Rust風のクリーンな設計 |
| 合成可能性の境界が曖昧 | 明確なサブセット分離 |
| UVMへの依存 | 言語組み込み検証機能 |

---

## 0.3 Hello World

IRISでの最小限のカウンタモジュールを見てみましょう。

```rust
/// 8ビットカウンタ
mod Counter(
    in  clk: clock,      // クロック入力
    in  rst: reset,      // リセット入力
    in  enable: bit,     // カウント有効信号
    out count: bit[8],   // 8ビット出力
) {
    // 可変信号（レジスタ）
    var counter: bit[8] = 0;

    // 順序論理：クロック立ち上がりで更新
    sync(clk.posedge, rst.async) {
        if enable {
            counter = counter + 1;
        }
    }

    // 組み合わせ論理：出力接続
    comb {
        count = counter;
    }
}
```

### コードの解説

1. **モジュール定義**: `mod` キーワードでモジュールを宣言
2. **ポート宣言**: `in` / `out` で入出力ポートを定義
3. **レジスタ宣言**: `var` で順序論理用の信号を宣言
4. **順序論理**: `sync` ブロックでクロック同期の動作を記述
5. **組み合わせ論理**: `comb` ブロックで組み合わせ回路を記述

> **ポイント**: IRISでは代入演算子が `=` に統一されています。`sync` ブロック内では自動的にレジスタ更新として扱われます。
>
> **リセット動作**: `var counter: bit[8] = 0;` のように宣言時の初期値が、`sync`ブロックで指定されたリセット信号（`rst.async`）が入った際のリセット値として自動的に使用されます。SystemVerilogのような明示的なリセット分岐は不要です。

---

## 0.4 本書の構成と使い方

### プロジェクトベース学習

本書では、実際のプロジェクトを作成しながら学習を進めます。

**Part 1で構築するプロジェクト：LEDコントローラ**

```
スイッチ入力 → LED制御FSM → LED出力
```

このプロジェクトを通じて、基本モジュール、組み合わせ論理、順序論理、FSMを学びます。

**Part 2で拡張するプロジェクト：UART送受信**

```
TX/RXインターフェース → FIFO → 制御FSM
```

インターフェース、パラメータ化、メモリの概念を学びます。

### 本書の構成

| パート | 内容 | 学習目標 |
|--------|------|----------|
| **序章** | IRISの概要 | 言語の全体像を把握 |
| **Part 1 基礎編** | モジュール、型、論理回路 | 基本的な回路を記述できる |
| **Part 2 中級編** | FSM、インターフェース、メモリ | 再利用可能な設計ができる |
| **Part 3 上級編** | 検証、デザインパターン、移行 | 実践的な開発ができる |
| **付録** | リファレンス、用語集 | 参照用 |

### 学習の進め方

1. 各章の「学習目標」を確認する
2. 解説とコード例を読む
3. 練習問題に取り組む
4. まとめで理解を確認する
5. 詳細は仕様書の該当章を参照する

---

## 0.5 SystemVerilogとの対比

SystemVerilogの経験がある読者のために、主な構文の対比表を示します。

| 機能 | SystemVerilog | IRIS |
|------|---------------|------|
| 括弧 | `begin ... end` | `{ ... }` |
| ビット幅宣言 | `[7:0] bus` | `bit[8] bus` |
| 型宣言（組み合わせ） | `wire [7:0] data` | `let data: bit[8];` |
| 型宣言（順序） | `reg [7:0] data` | `var data: bit[8];` |
| 分岐 | `case ... endcase` | `match { ... }` |
| 組み合わせ論理 | `assign` / `always_comb` | `let` / `comb { }` |
| クロック | `always_ff @(posedge clk)` | `sync(clk.posedge) { }` |
| リセット記述 | `if (rst) q <= 0; else ...` | `sync(clk.posedge, rst.async) { ... }`（初期値が自動適用） |
| モジュール | `module ... endmodule` | `mod ... { }` |
| 代入演算子 | `=` / `<=` | `=`（統一） |

---

## まとめ

- IRISはRustの設計思想を取り入れた現代的なHDL
- 型安全性と簡潔な構文が特徴
- 代入演算子が統一され、学習しやすい
- プロジェクトベース学習で実践力を身につける

---

## 参考リンク

- [IRIS言語仕様書 第1章 概要](../../spec/01_overview.md)